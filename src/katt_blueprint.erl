-module(katt_blueprint).
-export([parse/1,file/1]).
-compile({nowarn_unused_function,[p/4, p/5, p_eof/0, p_optional/1, p_not/1, p_assert/1, p_seq/1, p_and/1, p_choose/1, p_zero_or_more/1, p_one_or_more/1, p_label/2, p_string/1, p_anything/0, p_charclass/1, p_regexp/1, p_attempt/4, line/1, column/1]}).



%%% This file is generated by neotoma.

-include_lib("katt/include/blueprint_types.hrl").

null_if_empty([])      -> null;
null_if_empty(String)  -> String.

concatenate_lines([H|_]=Lines) when is_binary(H) ->
  StringList = lists:map(fun unicode:characters_to_list/1, Lines),
  unicode:characters_to_binary(string:join(StringList, "\n"));
concatenate_lines([]) ->
  [].

concatenate_chars(Chars) ->
  << <<Char/utf8>> || <<Char/utf8>> <- Chars >>.


-spec file(file:name()) -> any().
file(Filename) -> {ok, Bin} = file:read_file(Filename), parse(Bin).

-spec parse(binary() | list()) -> any().
parse(List) when is_list(List) -> parse(list_to_binary(List));
parse(Input) when is_binary(Input) ->
  setup_memo(),
  Result = case 'api'(Input,{{line,1},{column,1}}) of
             {AST, <<>>, _Index} -> AST;
             Any -> Any
           end,
  release_memo(), Result.

'api'(Input, Index) ->
  p(Input, Index, 'api', fun(I,D) -> (p_seq([p_zero_or_more(fun 'empty_line'/2), p_label('name', p_optional(fun 'api_name'/2)), p_zero_or_more(fun 'empty_line'/2), p_label('description', p_optional(fun 'api_description'/2)), p_zero_or_more(fun 'empty_line'/2), p_label('transactions', fun 'transactions'/2), p_zero_or_more(fun 'empty_line'/2), fun 'eof'/2]))(I,D) end, fun(Node, _Idx) -> 
    Name = proplists:get_value(name, Node),
    Description = proplists:get_value(description, Node),
    Transactions = proplists:get_value(transactions, Node),
    #katt_blueprint{
      name=null_if_empty(Name),
      description=null_if_empty(Description),
      transactions=Transactions
    }
   end).

'api_name'(Input, Index) ->
  p(Input, Index, 'api_name', fun(I,D) -> (p_seq([p_not(fun 'http_method'/2), p_string(<<"---">>), p_one_or_more(fun 's'/2), p_label('name', fun 'text1'/2), fun 'eolf'/2]))(I,D) end, fun(Node, _Idx) -> 
    Name = proplists:get_value(name, Node),
    re:replace(Name, "\s+---$", "", [{return, binary}])
   end).

'api_description'(Input, Index) ->
  p(Input, Index, 'api_description', fun(I,D) -> (p_seq([p_not(fun 'http_method'/2), p_string(<<"---">>), p_zero_or_more(fun 's'/2), fun 'eol'/2, p_label('lines', p_zero_or_more(fun 'api_description_line'/2)), p_string(<<"---">>), p_zero_or_more(fun 's'/2), fun 'eolf'/2]))(I,D) end, fun(Node, _Idx) -> 
    concatenate_lines(proplists:get_value(lines, Node))
   end).

'api_description_line'(Input, Index) ->
  p(Input, Index, 'api_description_line', fun(I,D) -> (p_seq([p_not(p_seq([p_string(<<"---">>), p_zero_or_more(fun 's'/2), fun 'eolf'/2])), p_label('text', fun 'text0'/2), fun 'eol'/2]))(I,D) end, fun(Node, _Idx) -> 
    proplists:get_value(text, Node)
   end).

'transactions'(Input, Index) ->
  p(Input, Index, 'transactions', fun(I,D) -> (p_seq([p_label('head', p_optional(fun 'transaction'/2)), p_label('tail', p_zero_or_more(fun 'transactions_tail'/2))]))(I,D) end, fun(Node, _Idx) -> 
    Head = proplists:get_value(head, Node),
    Tail = proplists:get_value(tail, Node),
    case Head of
      [] -> Tail;
      _  -> [Head | Tail]
    end
   end).

'transactions_tail'(Input, Index) ->
  p(Input, Index, 'transactions_tail', fun(I,D) -> (p_seq([p_zero_or_more(fun 'empty_line'/2), p_label('transaction', fun 'transaction'/2)]))(I,D) end, fun(Node, _Idx) -> 
  proplists:get_value(transaction, Node)
   end).

'transaction'(Input, Index) ->
  p(Input, Index, 'transaction', fun(I,D) -> (p_seq([p_label('description', p_optional(fun 'transaction_description'/2)), p_label('request', fun 'request'/2), p_label('response', fun 'response'/2)]))(I,D) end, fun(Node, _Idx) -> 
    Description = proplists:get_value(description, Node),
    Request = proplists:get_value(request, Node),
    Response = proplists:get_value(response, Node),

    #katt_transaction{
      description=null_if_empty(Description),
      request=Request,
      response=Response
    }
   end).

'transaction_description'(Input, Index) ->
  p(Input, Index, 'transaction_description', fun(I,D) -> (p_one_or_more(fun 'transaction_description_line'/2))(I,D) end, fun(Node, _Idx) -> 
    concatenate_lines(Node)
   end).

'transaction_description_line'(Input, Index) ->
  p(Input, Index, 'transaction_description_line', fun(I,D) -> (p_seq([p_not(fun 'http_method'/2), p_label('text', fun 'text0'/2), fun 'eol'/2]))(I,D) end, fun(Node, _Idx) -> 
    proplists:get_value(text, Node)
   end).

'http_method'(Input, Index) ->
  p(Input, Index, 'http_method', fun(I,D) -> (p_choose([p_string(<<"GET">>), p_string(<<"POST">>), p_string(<<"PUT">>), p_string(<<"DELETE">>), p_string(<<"OPTIONS">>), p_string(<<"PATCH">>), p_string(<<"PROPPATCH">>), p_string(<<"LOCK">>), p_string(<<"UNLOCK">>), p_string(<<"COPY">>), p_string(<<"MOVE">>), p_string(<<"MKCOL">>), p_string(<<"HEAD">>)]))(I,D) end, fun(Node, _Idx) -> Node end).

'request'(Input, Index) ->
  p(Input, Index, 'request', fun(I,D) -> (p_seq([p_label('signature', fun 'signature'/2), p_label('headers', fun 'request_headers'/2), p_label('body', p_optional(fun 'body'/2))]))(I,D) end, fun(Node, _Idx) -> 
    {Method, Url} = proplists:get_value(signature, Node),
    Headers = proplists:get_value(headers, Node),
    Body = proplists:get_value(body, Node),
    #katt_request{
      method=Method,
      url=Url,
      headers=Headers,
      body=null_if_empty(Body)
    }
   end).

'request_headers'(Input, Index) ->
  p(Input, Index, 'request_headers', fun(I,D) -> (p_zero_or_more(fun 'request_header'/2))(I,D) end, fun(Node, _Idx) -> Node end).

'request_header'(Input, Index) ->
  p(Input, Index, 'request_header', fun(I,D) -> (p_seq([fun 'in'/2, p_label('header', fun 'http_header'/2)]))(I,D) end, fun(Node, _Idx) -> 
    proplists:get_value(header, Node)
   end).

'response'(Input, Index) ->
  p(Input, Index, 'response', fun(I,D) -> (p_seq([p_label('status', fun 'response_status'/2), p_label('headers', fun 'response_headers'/2), p_label('body', p_optional(fun 'body'/2))]))(I,D) end, fun(Node, _Idx) -> 
    Status = proplists:get_value(status, Node),
    Headers = proplists:get_value(headers, Node),
    Body = proplists:get_value(body, Node),
    #katt_response{
      status=Status,
      headers=Headers,
      body=null_if_empty(Body)
    }
   end).

'response_status'(Input, Index) ->
  p(Input, Index, 'response_status', fun(I,D) -> (p_seq([fun 'out'/2, p_label('status', fun 'http_status'/2), p_zero_or_more(fun 's'/2), fun 'eolf'/2]))(I,D) end, fun(Node, _Idx) -> 
    proplists:get_value(status, Node)
   end).

'response_headers'(Input, Index) ->
  p(Input, Index, 'response_headers', fun(I,D) -> (p_zero_or_more(fun 'response_header'/2))(I,D) end, fun(Node, _Idx) -> Node end).

'response_header'(Input, Index) ->
  p(Input, Index, 'response_header', fun(I,D) -> (p_seq([fun 'out'/2, fun 'http_header'/2]))(I,D) end, fun(Node, _Idx) -> 
    [_, Header] = Node,
    Header
   end).

'http_status'(Input, Index) ->
  p(Input, Index, 'http_status', fun(I,D) -> (p_seq([p_charclass(<<"[1-5]">>), p_charclass(<<"[0-9]">>), p_charclass(<<"[0-9]">>)]))(I,D) end, fun(Node, _Idx) -> 
    {Int, _Rest} = string:to_integer(unicode:characters_to_list(concatenate_chars(Node))),
    Int
   end).

'http_header'(Input, Index) ->
  p(Input, Index, 'http_header', fun(I,D) -> (p_seq([p_label('name', fun 'http_header_name'/2), p_string(<<":">>), p_zero_or_more(fun 's'/2), p_label('value', fun 'http_header_value'/2), fun 'eolf'/2]))(I,D) end, fun(Node, _Idx) -> 
    Name = proplists:get_value(name, Node),
    Value = proplists:get_value(value, Node),
    {Name, Value}
   end).

'http_header_name'(Input, Index) ->
  p(Input, Index, 'http_header_name', fun(I,D) -> (p_one_or_more(p_charclass(<<"[\x21-\x39\x3B-\x7E]">>)))(I,D) end, fun(Node, _Idx) -> 
    unicode:characters_to_list(concatenate_chars(Node))
   end).

'http_header_value'(Input, Index) ->
  p(Input, Index, 'http_header_value', fun(I,D) -> (fun 'text0'/2)(I,D) end, fun(Node, _Idx) -> 
    unicode:characters_to_list(Node)
   end).

'signature'(Input, Index) ->
  p(Input, Index, 'signature', fun(I,D) -> (p_seq([p_label('method', fun 'http_method'/2), p_one_or_more(fun 's'/2), p_label('url', fun 'text1'/2), fun 'eol'/2]))(I,D) end, fun(Node, _Idx) -> 
    Method = unicode:characters_to_list(proplists:get_value(method, Node)),
    Url = unicode:characters_to_list(proplists:get_value(url, Node)),
    {Method, Url}
   end).

'body'(Input, Index) ->
  p(Input, Index, 'body', fun(I,D) -> (p_choose([fun 'delimited_body_fixed'/2, fun 'simple_body'/2]))(I,D) end, fun(Node, _Idx) -> Node end).

'delimited_body_fixed'(Input, Index) ->
  p(Input, Index, 'delimited_body_fixed', fun(I,D) -> (p_seq([p_string(<<"<<<">>), p_zero_or_more(fun 's'/2), fun 'eol'/2, p_label('lines', p_zero_or_more(fun 'delimited_body_fixed_line'/2)), p_string(<<">>>">>), p_zero_or_more(fun 's'/2), fun 'eolf'/2]))(I,D) end, fun(Node, _Idx) -> 
    concatenate_lines(proplists:get_value(lines, Node))
   end).

'delimited_body_fixed_line'(Input, Index) ->
  p(Input, Index, 'delimited_body_fixed_line', fun(I,D) -> (p_seq([p_not(p_seq([p_string(<<">>>">>), p_zero_or_more(fun 's'/2), fun 'eolf'/2])), p_label('text', fun 'text0'/2), fun 'eol'/2]))(I,D) end, fun(Node, _Idx) -> 
    proplists:get_value(text, Node)
   end).

'simple_body'(Input, Index) ->
  p(Input, Index, 'simple_body', fun(I,D) -> (p_seq([p_not(p_string(<<"<<<">>)), p_label('lines', p_one_or_more(fun 'simple_body_line'/2))]))(I,D) end, fun(Node, _Idx) -> 
    concatenate_lines(proplists:get_value(lines, Node))
   end).

'simple_body_line'(Input, Index) ->
  p(Input, Index, 'simple_body_line', fun(I,D) -> (p_seq([p_not(fun 'in'/2), p_not(fun 'out'/2), p_not(fun 'empty_line'/2), p_label('text', fun 'text1'/2), fun 'eolf'/2]))(I,D) end, fun(Node, _Idx) -> 
    proplists:get_value(text, Node)
   end).

'in'(Input, Index) ->
  p(Input, Index, 'in', fun(I,D) -> (p_seq([p_string(<<">">>), p_one_or_more(fun 's'/2)]))(I,D) end, fun(Node, _Idx) -> Node end).

'out'(Input, Index) ->
  p(Input, Index, 'out', fun(I,D) -> (p_seq([p_string(<<"<">>), p_one_or_more(fun 's'/2)]))(I,D) end, fun(Node, _Idx) -> Node end).

'text0'(Input, Index) ->
  p(Input, Index, 'text0', fun(I,D) -> (p_zero_or_more(p_charclass(<<"[^\n\r]">>)))(I,D) end, fun(Node, _Idx) -> 
  concatenate_chars(Node)
   end).

'text1'(Input, Index) ->
  p(Input, Index, 'text1', fun(I,D) -> (p_one_or_more(p_charclass(<<"[^\n\r]">>)))(I,D) end, fun(Node, _Idx) -> 
  concatenate_chars(Node)
   end).

'empty_line'(Input, Index) ->
  p(Input, Index, 'empty_line', fun(I,D) -> (p_seq([p_zero_or_more(fun 's'/2), fun 'eol'/2]))(I,D) end, fun(Node, _Idx) -> Node end).

'eolf'(Input, Index) ->
  p(Input, Index, 'eolf', fun(I,D) -> (p_choose([fun 'eol'/2, fun 'eof'/2]))(I,D) end, fun(Node, _Idx) -> Node end).

'eol'(Input, Index) ->
  p(Input, Index, 'eol', fun(I,D) -> (p_choose([p_string(<<"\n">>), p_string(<<"\r\n">>), p_string(<<"\r">>)]))(I,D) end, fun(Node, _Idx) -> Node end).

'eof'(Input, Index) ->
  p(Input, Index, 'eof', fun(I,D) -> (p_not(p_anything()))(I,D) end, fun(_Node, _Idx) ->  <<>>  end).

's'(Input, Index) ->
  p(Input, Index, 's', fun(I,D) -> (p_charclass(<<"[\t\v\f\s]">>))(I,D) end, fun(Node, _Idx) -> Node end).




p(Inp, Index, Name, ParseFun) ->
  p(Inp, Index, Name, ParseFun, fun(N, _Idx) -> N end).

p(Inp, StartIndex, Name, ParseFun, TransformFun) ->
  case get_memo(StartIndex, Name) of      % See if the current reduction is memoized
    {ok, Memo} -> %Memo;                     % If it is, return the stored result
      Memo;
    _ ->                                        % If not, attempt to parse
      Result = case ParseFun(Inp, StartIndex) of
        {fail,_} = Failure ->                       % If it fails, memoize the failure
          Failure;
        {Match, InpRem, NewIndex} ->               % If it passes, transform and memoize the result.
          Transformed = TransformFun(Match, StartIndex),
          {Transformed, InpRem, NewIndex}
      end,
      memoize(StartIndex, Name, Result),
      Result
  end.

setup_memo() ->
  put({parse_memo_table, ?MODULE}, ets:new(?MODULE, [set])).

release_memo() ->
  ets:delete(memo_table_name()).

memoize(Index, Name, Result) ->
  Memo = case ets:lookup(memo_table_name(), Index) of
              [] -> [];
              [{Index, Plist}] -> Plist
         end,
  ets:insert(memo_table_name(), {Index, [{Name, Result}|Memo]}).

get_memo(Index, Name) ->
  case ets:lookup(memo_table_name(), Index) of
    [] -> {error, not_found};
    [{Index, Plist}] ->
      case proplists:lookup(Name, Plist) of
        {Name, Result}  -> {ok, Result};
        _  -> {error, not_found}
      end
    end.

memo_table_name() ->
    get({parse_memo_table, ?MODULE}).

p_eof() ->
  fun(<<>>, Index) -> {eof, [], Index};
     (_, Index) -> {fail, {expected, eof, Index}} end.

p_optional(P) ->
  fun(Input, Index) ->
      case P(Input, Index) of
        {fail,_} -> {[], Input, Index};
        {_, _, _} = Success -> Success
      end
  end.

p_not(P) ->
  fun(Input, Index)->
      case P(Input,Index) of
        {fail,_} ->
          {[], Input, Index};
        {Result, _, _} -> {fail, {expected, {no_match, Result},Index}}
      end
  end.

p_assert(P) ->
  fun(Input,Index) ->
      case P(Input,Index) of
        {fail,_} = Failure-> Failure;
        _ -> {[], Input, Index}
      end
  end.

p_and(P) ->
  p_seq(P).

p_seq(P) ->
  fun(Input, Index) ->
      p_all(P, Input, Index, [])
  end.

p_all([], Inp, Index, Accum ) -> {lists:reverse( Accum ), Inp, Index};
p_all([P|Parsers], Inp, Index, Accum) ->
  case P(Inp, Index) of
    {fail, _} = Failure -> Failure;
    {Result, InpRem, NewIndex} -> p_all(Parsers, InpRem, NewIndex, [Result|Accum])
  end.

p_choose(Parsers) ->
  fun(Input, Index) ->
      p_attempt(Parsers, Input, Index, none)
  end.

p_attempt([], _Input, _Index, Failure) -> Failure;
p_attempt([P|Parsers], Input, Index, FirstFailure)->
  case P(Input, Index) of
    {fail, _} = Failure ->
      case FirstFailure of
        none -> p_attempt(Parsers, Input, Index, Failure);
        _ -> p_attempt(Parsers, Input, Index, FirstFailure)
      end;
    Result -> Result
  end.

p_zero_or_more(P) ->
  fun(Input, Index) ->
      p_scan(P, Input, Index, [])
  end.

p_one_or_more(P) ->
  fun(Input, Index)->
      Result = p_scan(P, Input, Index, []),
      case Result of
        {[_|_], _, _} ->
          Result;
        _ ->
          {fail, {expected, Failure, _}} = P(Input,Index),
          {fail, {expected, {at_least_one, Failure}, Index}}
      end
  end.

p_label(Tag, P) ->
  fun(Input, Index) ->
      case P(Input, Index) of
        {fail,_} = Failure ->
           Failure;
        {Result, InpRem, NewIndex} ->
          {{Tag, Result}, InpRem, NewIndex}
      end
  end.

p_scan(_, [], Index, Accum) -> {lists:reverse( Accum ), [], Index};
p_scan(P, Inp, Index, Accum) ->
  case P(Inp, Index) of
    {fail,_} -> {lists:reverse(Accum), Inp, Index};
    {Result, InpRem, NewIndex} -> p_scan(P, InpRem, NewIndex, [Result | Accum])
  end.

p_string(S) when is_list(S) -> p_string(list_to_binary(S));
p_string(S) ->
    Length = erlang:byte_size(S),
    fun(Input, Index) ->
      try
          <<S:Length/binary, Rest/binary>> = Input,
          {S, Rest, p_advance_index(S, Index)}
      catch
          error:{badmatch,_} -> {fail, {expected, {string, S}, Index}}
      end
    end.

p_anything() ->
  fun(<<>>, Index) -> {fail, {expected, any_character, Index}};
     (Input, Index) when is_binary(Input) ->
          <<C/utf8, Rest/binary>> = Input,
          {<<C/utf8>>, Rest, p_advance_index(<<C/utf8>>, Index)}
  end.

p_charclass(Class) ->
    {ok, RE} = re:compile(Class, [unicode, dotall]),
    fun(Inp, Index) ->
            case re:run(Inp, RE, [anchored]) of
                {match, [{0, Length}|_]} ->
                    {Head, Tail} = erlang:split_binary(Inp, Length),
                    {Head, Tail, p_advance_index(Head, Index)};
                _ -> {fail, {expected, {character_class, binary_to_list(Class)}, Index}}
            end
    end.

p_regexp(Regexp) ->
    {ok, RE} = re:compile(Regexp, [unicode, dotall, anchored]),
    fun(Inp, Index) ->
        case re:run(Inp, RE) of
            {match, [{0, Length}|_]} ->
                {Head, Tail} = erlang:split_binary(Inp, Length),
                {Head, Tail, p_advance_index(Head, Index)};
            _ -> {fail, {expected, {regexp, binary_to_list(Regexp)}, Index}}
        end
    end.

line({{line,L},_}) -> L;
line(_) -> undefined.

column({_,{column,C}}) -> C;
column(_) -> undefined.

p_advance_index(MatchedInput, Index) when is_list(MatchedInput) orelse is_binary(MatchedInput)-> % strings
  lists:foldl(fun p_advance_index/2, Index, unicode:characters_to_list(MatchedInput));
p_advance_index(MatchedInput, Index) when is_integer(MatchedInput) -> % single characters
  {{line, Line}, {column, Col}} = Index,
  case MatchedInput of
    $\n -> {{line, Line+1}, {column, 1}};
    _ -> {{line, Line}, {column, Col+1}}
  end.
